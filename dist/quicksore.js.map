{"version":3,"sources":["node_modules/quick-score/lib/index.esm.js","quicksore.js"],"names":["Range","location","length","value","max","BaseConfigDefaults","wordSeparators","uppercaseLetters","charCodeA","charCodeAt","uppercase","i","push","String","fromCharCode","join","ignoredScore","skippedScore","emptyQueryScore","QSConfigDefaults","longStringLength","maxMatchStartPct","minMatchDensityPct","maxMatchDensityPct","beginningOfStringPct","Config","options","Object","assign","string","query","remainingScore","skippedSpecialChar","searchRange","remainingSearchRange","matchedRange","fullMatchedRange","QuickScoreConfig","len","isShortString","matchStartPercentage","matchRangeDiscount","matchStartDiscount","Math","min","createConfig","DefaultConfig","BaseConfig","QuicksilverConfig","adjustRemainingScore","score","quickScore","matches","lcString","toLocaleLowerCase","lcQuery","config","stringRange","calcScore","queryRange","initialMatchesLength","querySubstring","substring","getRangeOfSubstring","isValid","remainingQueryRange","useSkipReduction","indexOf","j","stringToSearch","subStringIndex","result","QuickScore","items","optionsValue","Array","keys","scorer","minimumScore","setKeys","setItems","compareScoredStrings","bind","results","lcItems","minScore","item","lc","scoreKey","scores","_","highScore","jlen","key","name","getItemString","newScore","sort","from","map","keyItem","path","split","defaultKeyName","reduce","prop","a","b","itemA","itemB","itemAString","itemBString","undefined","window"],"mappings":"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","file":"quicksore.js","sourceRoot":"..","sourcesContent":["/**\r\n * A class representing a half-open interval of characters.  A range's `location`\r\n * property and `max()` value can be used as arguments for the `substring()`\r\n * method to extract a range of characters.\r\n */\r\nclass Range {\r\n\t/**\r\n\t * @param {number} [location=-1] - Starting index of the range.\r\n\t * @param {number} [length=0] - Number of characters in the range.\r\n\t */\r\n\tconstructor(\r\n\t\tlocation,\r\n\t\tlength)\r\n\t{\r\n\t\tif (typeof location == \"number\") {\r\n\t\t\tthis.location = location;\r\n\t\t\tthis.length = length;\r\n\t\t} else {\r\n\t\t\tthis.location = -1;\r\n\t\t\tthis.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/* eslint no-inline-comments: 0 */\r\n\t/**\r\n\t * Gets the end index of the range, which indicates the character\r\n\t * immediately after the last one in the range.\r\n\t *\r\n\t * @returns {number}\r\n\t *//**\r\n\t * Sets the end index of the range, which indicates the character\r\n\t * immediately after the last one in the range.\r\n\t *\r\n\t * @param {number} [value] - End of the range.\r\n\t *\r\n\t * @returns {number}\r\n\t */\r\n\tmax(\r\n\t\tvalue)\r\n\t{\r\n\t\tif (typeof value == \"number\") {\r\n\t\t\tthis.length = value - this.location;\r\n\t\t}\r\n\r\n\t\t\t// the NSMaxRange() function in Objective-C returns this value\r\n\t\treturn this.location + this.length;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns whether the range contains a location >= 0.\r\n\t *\r\n\t * @returns {boolean}\r\n\t */\r\n\tisValid()\r\n\t{\r\n\t\treturn (this.location > -1);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns an array of the range's start and end indexes.\r\n\t *\r\n\t * @returns {Array<number>}\r\n\t */\r\n\ttoArray()\r\n\t{\r\n\t\treturn [this.location, this.max()];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a string representation of the range's open interval.\r\n\t *\r\n\t * @returns {string}\r\n\t */\r\n\ttoString()\r\n\t{\r\n\t\tif (this.location == -1) {\r\n\t\t\treturn \"invalid range\";\r\n\t\t} else {\r\n\t\t\treturn \"[\" + this.location + \",\" + this.max() + \")\";\r\n\t\t}\r\n\t}\r\n}\n\nconst BaseConfigDefaults = {\r\n\twordSeparators: \"-/\\\\:()<>%._=&[]+ \\t\\n\\r\",\r\n\tuppercaseLetters: (() => {\r\n\t\tconst charCodeA = \"A\".charCodeAt(0);\r\n\t\tconst uppercase = [];\r\n\r\n\t\tfor (let i = 0; i < 26; i++) {\r\n\t\t\tuppercase.push(String.fromCharCode(charCodeA + i));\r\n\t\t}\r\n\r\n\t\treturn uppercase.join(\"\");\r\n\t})(),\r\n\tignoredScore: 0.9,\r\n\tskippedScore: 0.15,\r\n\temptyQueryScore: 0\r\n};\r\nconst QSConfigDefaults = {\r\n\tlongStringLength: 150,\r\n\tmaxMatchStartPct: 0.15,\r\n\tminMatchDensityPct: 0.75,\r\n\tmaxMatchDensityPct: 0.95,\r\n\tbeginningOfStringPct: 0.1\r\n};\r\n\r\n\r\nclass Config {\r\n\tconstructor(\r\n\t\toptions)\r\n\t{\r\n\t\tObject.assign(this, BaseConfigDefaults, options);\r\n\t}\r\n\r\n\r\n\tuseSkipReduction()\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tadjustRemainingScore(\r\n\t\tstring,\r\n\t\tquery,\r\n\t\tremainingScore,\r\n\t\tskippedSpecialChar,\r\n\t\tsearchRange,\r\n\t\tremainingSearchRange,\r\n\t\tmatchedRange,\r\n\t\tfullMatchedRange)\r\n\t{\r\n\t\t\t// use the original Quicksilver expression for the remainingScore\r\n\t\treturn remainingScore * remainingSearchRange.length;\r\n\t}\r\n}\r\n\r\n\r\nclass QuickScoreConfig extends Config {\r\n\tconstructor(\r\n\t\toptions)\r\n\t{\r\n\t\tsuper(Object.assign({}, QSConfigDefaults, options));\r\n\t}\r\n\r\n\r\n\tuseSkipReduction(\r\n\t\tstring,\r\n\t\tquery,\r\n\t\tremainingScore,\r\n\t\tsearchRange,\r\n\t\tremainingSearchRange,\r\n\t\tmatchedRange,\r\n\t\tfullMatchedRange)\r\n\t{\r\n\t\tconst len = string.length;\r\n\t\tconst isShortString = len <= this.longStringLength;\r\n\t\tconst matchStartPercentage = fullMatchedRange.location / len;\r\n\r\n\t\treturn isShortString || matchStartPercentage < this.maxMatchStartPct;\r\n\t}\r\n\r\n\r\n\tadjustRemainingScore(\r\n\t\tstring,\r\n\t\tquery,\r\n\t\tremainingScore,\r\n\t\tskippedSpecialChar,\r\n\t\tsearchRange,\r\n\t\tremainingSearchRange,\r\n\t\tmatchedRange,\r\n\t\tfullMatchedRange)\r\n\t{\r\n\t\tconst isShortString = string.length <= this.longStringLength;\r\n\t\tconst matchStartPercentage = fullMatchedRange.location / string.length;\r\n\t\tlet matchRangeDiscount = 1;\r\n\t\tlet matchStartDiscount = (1 - matchStartPercentage);\r\n\r\n\t\t\t// discount the remainingScore based on how much larger the match is\r\n\t\t\t// than the query, unless the match is in the first 10% of the\r\n\t\t\t// string, the match range isn't too sparse and the whole string is\r\n\t\t\t// not too long.  also only discount if we didn't skip any whitespace\r\n\t\t\t// or capitals.\r\n\t\tif (!skippedSpecialChar) {\r\n\t\t\tmatchRangeDiscount = query.length / fullMatchedRange.length;\r\n\t\t\tmatchRangeDiscount = (isShortString &&\r\n\t\t\t\tmatchStartPercentage <= this.beginningOfStringPct &&\r\n\t\t\t\tmatchRangeDiscount >= this.minMatchDensityPct) ?\r\n\t\t\t\t1 : matchRangeDiscount;\r\n\t\t\tmatchStartDiscount = matchRangeDiscount >= this.maxMatchDensityPct ?\r\n\t\t\t\t1 : matchStartDiscount;\r\n\t\t}\r\n\r\n\t\t\t// discount the scores of very long strings\r\n\t\treturn remainingScore *\r\n\t\t\tMath.min(remainingSearchRange.length, this.longStringLength) *\r\n\t\t\tmatchRangeDiscount * matchStartDiscount;\r\n\t}\r\n}\r\n\r\n\r\nfunction createConfig(\r\n\toptions)\r\n{\r\n\tif (options instanceof Config) {\r\n\t\t\t// this is a full-fledged Config instance, so we don't need to do\r\n\t\t\t// anything to it\r\n\t\treturn options;\r\n\t} else {\r\n\t\t\t// create a complete config from this\r\n\t\treturn new QuickScoreConfig(options);\r\n\t}\r\n}\r\n\r\n\r\nconst DefaultConfig = createConfig();\r\nconst BaseConfig = new Config();\r\nconst QuicksilverConfig = new Config({\r\n\t\t// the Quicksilver algorithm returns .9 for empty queries\r\n\temptyQueryScore: 0.9,\r\n\tadjustRemainingScore: function(\r\n\t\tstring,\r\n\t\tquery,\r\n\t\tremainingScore,\r\n\t\tskippedSpecialChar,\r\n\t\tsearchRange,\r\n\t\tremainingSearchRange,\r\n\t\tmatchedRange,\r\n\t\tfullMatchedRange)\r\n\t{\r\n\t\tlet score = remainingScore * remainingSearchRange.length;\r\n\r\n\t\tif (!skippedSpecialChar) {\r\n\t\t\t\t// the current QuickSilver algorithm reduces the score by half\r\n\t\t\t\t// this value when no special chars are skipped, so add the half\r\n\t\t\t\t// back in to match it\r\n\t\t\tscore += ((matchedRange.location - searchRange.location) / 2.0);\r\n\t\t}\r\n\r\n\t\treturn score;\r\n\t}\r\n});\n\n/**\r\n * Scores a string against a query.\r\n *\r\n * @param {string} string - The string to score.\r\n *\r\n * @param {string} query - The query string to score the `string` parameter against.\r\n *\r\n * @param {Array} [matches] - If supplied, the `quickScore()` will push\r\n * onto `matches` an array with start and end indexes for each substring range\r\n * of `string` that matches `query`.  These indexes can be used to highlight the\r\n * matching characters in an auto-complete UI.\r\n *\r\n * @param {string} [lcString] - A lowercase version of `string`.\r\n *\r\n * @param {string} [lcQuery] - A lowercase version of `query`.\r\n *\r\n * @param {object} [config] - A configuration object that can modify how the\r\n * `quickScore` algorithm behaves.\r\n *\r\n * @param {Range} [stringRange] - The range of characters in `string` that should\r\n * be checked for matches against `query`.  Defaults to all of the `string`\r\n * parameter.\r\n *\r\n * @returns {number}\r\n */\r\nfunction quickScore(\r\n\tstring = \"\",\r\n\tquery = \"\",\r\n\tmatches,\r\n\tlcString = string.toLocaleLowerCase(),\r\n\tlcQuery = query.toLocaleLowerCase(),\r\n\tconfig = DefaultConfig,\r\n\tstringRange = new Range(0, string.length))\r\n{\r\n\tif (!query) {\r\n\t\treturn config.emptyQueryScore;\r\n\t}\r\n\r\n\treturn calcScore(stringRange, new Range(0, query.length), new Range());\r\n\r\n\r\n\tfunction calcScore(\r\n\t\tsearchRange,\r\n\t\tqueryRange,\r\n\t\tfullMatchedRange)\r\n\t{\r\n\t\tif (!queryRange.length) {\r\n\t\t\t\t// deduct some points for all remaining characters\r\n\t\t\treturn config.ignoredScore;\r\n\t\t}\r\n\r\n\t\tif (queryRange.length > searchRange.length) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tconst initialMatchesLength = matches && matches.length;\r\n\r\n\t\tfor (let i = queryRange.length; i > 0; i--) {\r\n\t\t\tconst querySubstring = lcQuery.substring(queryRange.location, queryRange.location + i);\r\n\t\t\t\t// reduce the length of the search range by the number of chars\r\n\t\t\t\t// we're skipping in the query, to make sure there's enough string\r\n\t\t\t\t// left to possibly contain the skipped chars\r\n\t\t\tconst matchedRange = getRangeOfSubstring(lcString, querySubstring,\r\n\t\t\t\tnew Range(searchRange.location, searchRange.length - queryRange.length + i));\r\n\r\n\t\t\tif (!matchedRange.isValid()) {\r\n\t\t\t\t\t// we didn't find the query substring, so try again with a\r\n\t\t\t\t\t// shorter substring\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (!fullMatchedRange.isValid()) {\r\n\t\t\t\tfullMatchedRange.location = matchedRange.location;\r\n\t\t\t} else {\r\n\t\t\t\tfullMatchedRange.location = Math.min(fullMatchedRange.location, matchedRange.location);\r\n\t\t\t}\r\n\r\n\t\t\tfullMatchedRange.max(matchedRange.max());\r\n\r\n\t\t\tif (matches) {\r\n\t\t\t\tmatches.push([matchedRange.location, matchedRange.max()]);\r\n\t\t\t}\r\n\r\n\t\t\tconst remainingSearchRange = new Range(matchedRange.max(), searchRange.max() - matchedRange.max());\r\n\t\t\tconst remainingQueryRange = new Range(queryRange.location + i, queryRange.length - i);\r\n\t\t\tconst remainingScore = calcScore(remainingSearchRange, remainingQueryRange, fullMatchedRange);\r\n\r\n\t\t\tif (remainingScore) {\r\n\t\t\t\tlet score = remainingSearchRange.location - searchRange.location;\r\n\t\t\t\t\t// default to true since we only want to apply a discount if\r\n\t\t\t\t\t// we hit the final else clause below, and we won't get to\r\n\t\t\t\t\t// any of them if the match is right at the start of the\r\n\t\t\t\t\t// searchRange\r\n\t\t\t\tlet skippedSpecialChar = true;\r\n\t\t\t\tconst useSkipReduction = config.useSkipReduction(string, query,\r\n\t\t\t\t\tremainingScore, remainingSearchRange, searchRange,\r\n\t\t\t\t\tremainingSearchRange, matchedRange, fullMatchedRange);\r\n\r\n\t\t\t\tif (matchedRange.location > searchRange.location) {\r\n\t\t\t\t\t\t// some letters were skipped when finding this match, so\r\n\t\t\t\t\t\t// adjust the score based on whether spaces or capital\r\n\t\t\t\t\t\t// letters were skipped\r\n\t\t\t\t\tif (useSkipReduction &&\r\n\t\t\t\t\t\t\tconfig.wordSeparators.indexOf(string[matchedRange.location - 1]) > -1) {\r\n\t\t\t\t\t\tfor (let j = matchedRange.location - 2; j >= searchRange.location; j--) {\r\n\t\t\t\t\t\t\tif (config.wordSeparators.indexOf(string[j]) > -1) {\r\n\t\t\t\t\t\t\t\tscore--;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tscore -= config.skippedScore;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (useSkipReduction &&\r\n\t\t\t\t\t\t\tconfig.uppercaseLetters.indexOf(string[matchedRange.location]) > -1) {\r\n\t\t\t\t\t\tfor (let j = matchedRange.location - 1; j >= searchRange.location; j--) {\r\n\t\t\t\t\t\t\tif (config.uppercaseLetters.indexOf(string[j]) > -1) {\r\n\t\t\t\t\t\t\t\tscore--;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tscore -= config.skippedScore;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// reduce the score by the number of chars we've\r\n\t\t\t\t\t\t\t// skipped since the beginning of the search range\r\n\t\t\t\t\t\tscore -= matchedRange.location - searchRange.location;\r\n\t\t\t\t\t\tskippedSpecialChar = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscore += config.adjustRemainingScore(string,\r\n\t\t\t\t\tquery, remainingScore, skippedSpecialChar, searchRange,\r\n\t\t\t\t\tremainingSearchRange, matchedRange, fullMatchedRange);\r\n\t\t\t\tscore /= searchRange.length;\r\n\r\n\t\t\t\treturn score;\r\n\t\t\t} else if (matches) {\r\n\t\t\t\t\t// the remaining query does not appear in the remaining\r\n\t\t\t\t\t// string, so strip off any matches we've added during the\r\n\t\t\t\t\t// current call, as they'll be invalid when we start over\r\n\t\t\t\t\t// with a shorter piece of the query\r\n\t\t\t\tmatches.length = initialMatchesLength;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n\t// make createConfig() available on quickScore so that the QuickScore\r\n\t// constructor has access to it\r\nquickScore.createConfig = createConfig;\r\n\r\n\r\nfunction getRangeOfSubstring(\r\n\tstring,\r\n\tsubstring,\r\n\tsearchRange)\r\n{\r\n\tconst stringToSearch = string.substring(searchRange.location, searchRange.max());\r\n\tconst subStringIndex = stringToSearch.indexOf(substring);\r\n\tconst result = new Range();\r\n\r\n\tif (subStringIndex > -1) {\r\n\t\tresult.location = subStringIndex + searchRange.location;\r\n\t\tresult.length = substring.length;\r\n\t}\r\n\r\n\treturn result;\r\n}\n\n/**\r\n * A class for scoring and sorting a list of items against a query string.  Each\r\n * item receives a floating point score between `0` and `1`.\r\n */\r\nclass QuickScore {\r\n\t/**\r\n\t * @param {Array<string> | Array<object>} [items] - The list of items to\r\n\t * score.  If the list is not a flat array of strings, a `keys` array must\r\n\t * be supplied via the second parameter.  The `items` array is not modified\r\n\t * by QuickScore.\r\n\t *\r\n\t * @param {Array<string> | object} [options] - If the `items` parameter is\r\n\t * an array of flat strings, the `options` parameter can be left out.  If\r\n\t * it is a list of objects containing keys that should be scored, the\r\n\t * `options` parameter must either be an array of key names or an object\r\n\t * containing a `keys` property.\r\n\t *\r\n\t * @param {Array<string> | Array<{name: string, scorer: function}>} [options.keys] -\r\n\t * In the simplest case, an array of key names to score on the objects\r\n\t * in the `items` array.  The first item in this array is considered the\r\n\t * primary key, which is used to sort items when they have the same\r\n\t * score.  The key name strings can point to a nested key by specifying a\r\n\t * dot-delimited path to the value.  So a key `name` of `\"foo.bar\"` would\r\n\t * evaluate to `\"baz\"` given an object like `{ foo: { bar: \"baz\" } }`.\r\n\t *\r\n\t * Each item in `keys` can instead be a `{name, scorer}` object, which\r\n\t * lets you specify a different scoring function for each key.  The\r\n\t * scoring function should behave as described next.\r\n\t *\r\n\t * @param {function(string, string, array?): number} [options.scorer] -\r\n\t * An optional function that takes `string` and `query` parameters and\r\n\t * returns a floating point number between 0 and 1 that represents how\r\n\t * well the `query` matches the `string`.  It defaults to the\r\n\t * [quickScore()]{@link quickScore} function in this library.\r\n\t *\r\n\t * If the function gets a `matches` parameter, it should fill the\r\n\t * passed in array with indexes corresponding to where the query\r\n\t * matches the string, as described in the [search()]{@link QuickScore#search}\r\n\t * method.\r\n\t *\r\n\t * @param {object} [options.config] - An optional object that can be passed\r\n\t * to the scorer function to further customize it's behavior.  If the\r\n\t * `scorer` function has a `createConfig()` method on it, the `QuickScore`\r\n\t * instance will call that with the `config` value and store the result.\r\n\t * This can be used to extend the `config` parameter with default values.\r\n\t *\r\n\t * @param {number} [options.minimumScore=0] - An optional value that\r\n\t * specifies the minimum score an item must have to appear in the results\r\n\t * array returned from [search()]{@link QuickScore#search}.  Defaults to `0`,\r\n\t * so items that don't match the full `query` will not be returned.  This\r\n\t * value is ignored if the `query` is empty or undefined, in which case all\r\n\t * items are returned, sorted alphabetically and case-insensitively.\r\n\t */\r\n\tconstructor(\r\n\t\titems = [],\r\n\t\toptions = {})\r\n\t{\r\n\t\tlet optionsValue = options;\r\n\r\n\t\tif (options instanceof Array) {\r\n\t\t\toptionsValue = { keys: options };\r\n\t\t}\r\n\r\n\t\tconst {\r\n\t\t\tscorer = quickScore,\r\n\t\t\tkeys = [],\r\n\t\t\tminimumScore = 0,\r\n\t\t\tconfig\r\n\t\t} = optionsValue;\r\n\r\n\t\tthis.scorer = scorer;\r\n\t\tthis.minimumScore = minimumScore;\r\n\t\tthis.config = config;\r\n\r\n\t\tif (typeof scorer.createConfig == \"function\") {\r\n\t\t\t\t// let the scorer fill out the config with default values\r\n\t\t\tthis.config = scorer.createConfig(config);\r\n\t\t}\r\n\r\n\t\tthis.setKeys(keys);\r\n\t\tthis.setItems(items);\r\n\r\n\t\t\t// the scoring function needs access to this.defaultKeyName\r\n\t\tthis.compareScoredStrings = this.compareScoredStrings.bind(this);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Scores the instance's items against the `query` and sorts them from\r\n\t * highest to lowest.\r\n\t *\r\n\t * @param {string} query - The string to score each item against.\r\n\t *\r\n\t * @returns {Array<object>} When the instance's `items` are flat strings,\r\n\t * the result objects contain the following properties:\r\n\t *\r\n\t * - `item`: the string that was scored\r\n\t * - `score`: the floating point score of the string for the current query\r\n\t * - `matches`: an array of arrays that specifies the character ranges\r\n\t *   where the query matched the string\r\n\t *\r\n\t * When the `items` are objects, the result objects contain:\r\n\t *\r\n\t * - `item`: the object that was scored\r\n\t * - `score`: the highest score from among the individual key scores\r\n\t * - `scoreKey`: the name of the key with the highest score, which will be\r\n\t *   an empty string if they're all zero\r\n\t * - `scores`: a hash of the individual scores for each key\r\n\t * - `matches`: a hash of arrays that specify the character ranges of the\r\n\t *   query match for each key\r\n\t *\r\n\t * The results array is sorted high to low on each item's score.  Items with\r\n\t * identical scores are sorted alphabetically and case-insensitively on the\r\n\t * primary key.  Items with scores that are <= the `minimumScore` option\r\n\t * (defaults to `0`) are not returned, unless the `query` is falsy, in which\r\n\t * case all of the items are returned, sorted alphabetically.\r\n\t *\r\n\t * The arrays of start and end indices in the `matches` array can be used as\r\n\t * parameters to the `substring()` method to extract the characters from\r\n\t * each string that match the query.  This can then be used to format the\r\n\t * matching characters with a different color or style.\r\n\t *\r\n\t * Each result item also contains a `_` property, which contains lowercase\r\n\t * versions of the item's strings, and might contain additional internal\r\n\t * metadata in the future.  It can be ignored.\r\n\t */\r\n\tsearch(\r\n\t\tquery)\r\n\t{\r\n\t\tconst results = [];\r\n\t\tconst {items, lcItems, keys, config} = this;\r\n\t\t\t// if the query is empty, we want to return all items, so make the\r\n\t\t\t// minimum score less than 0\r\n\t\tconst minScore = query ? this.minimumScore : -1;\r\n\t\tconst lcQuery = query.toLocaleLowerCase();\r\n\r\n\t\tif (keys.length) {\r\n\t\t\tfor (let i = 0, len = items.length; i < len; i++) {\r\n\t\t\t\tconst item = items[i];\r\n\t\t\t\tconst lc = lcItems[i];\r\n\t\t\t\tconst result = {\r\n\t\t\t\t\titem,\r\n\t\t\t\t\tscore: 0,\r\n\t\t\t\t\tscoreKey: \"\",\r\n\t\t\t\t\tscores: {},\r\n\t\t\t\t\tmatches: {},\r\n\t\t\t\t\t_: lc\r\n\t\t\t\t};\r\n\t\t\t\tlet highScore = 0;\r\n\t\t\t\tlet scoreKey = \"\";\r\n\r\n\t\t\t\t\t// find the highest score for each keyed string on this item\r\n\t\t\t\tfor (let j = 0, jlen = keys.length; j < jlen; j++) {\r\n\t\t\t\t\tconst key = keys[j];\r\n\t\t\t\t\tconst {name} = key;\r\n\t\t\t\t\tconst lcString = lc[name];\r\n\r\n\t\t\t\t\t\t// setItems() checks for non-strings and empty strings\r\n\t\t\t\t\t\t// when creating the lc objects, so if the key doesn't\r\n\t\t\t\t\t\t// exist there, we can ignore it for this item\r\n\t\t\t\t\tif (lcString) {\r\n\t\t\t\t\t\tconst string = this.getItemString(item, key);\r\n\t\t\t\t\t\tconst matches = [];\r\n\t\t\t\t\t\tconst newScore = key.scorer(string, query, matches,\r\n\t\t\t\t\t\t\tlcString, lcQuery, config);\r\n\r\n\t\t\t\t\t\tresult.scores[name] = newScore;\r\n\t\t\t\t\t\tresult.matches[name] = matches;\r\n\r\n\t\t\t\t\t\tif (newScore > highScore) {\r\n\t\t\t\t\t\t\thighScore = newScore;\r\n\t\t\t\t\t\t\tscoreKey = name;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (highScore > minScore) {\r\n\t\t\t\t\tresult.score = highScore;\r\n\t\t\t\t\tresult.scoreKey = scoreKey;\r\n\t\t\t\t\tresults.push(result);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t\t// items is a flat array of strings\r\n\t\t\tfor (let i = 0, len = items.length; i < len; i++) {\r\n\t\t\t\tconst item = items[i];\r\n\t\t\t\tconst lc = lcItems[i];\r\n\t\t\t\tconst matches = [];\r\n\t\t\t\tconst score = this.scorer(item, query, matches, lc, lcQuery, config);\r\n\r\n\t\t\t\tif (score > minScore) {\r\n\t\t\t\t\tresults.push({\r\n\t\t\t\t\t\titem,\r\n\t\t\t\t\t\tscore,\r\n\t\t\t\t\t\tmatches,\r\n\t\t\t\t\t\t_: lc\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresults.sort(this.compareScoredStrings);\r\n\r\n\t\treturn results;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets the `keys` configuration.\r\n\t *\r\n\t * @param {Array<string> | Array<object>} keys - List of keys to score, as\r\n\t * either flat strings or `{key, scorer}` objects.\r\n\t */\r\n\tsetKeys(\r\n\t\tkeys)\r\n\t{\r\n\t\tthis.keys = Array.from(keys);\r\n\r\n\t\tif (this.keys.length) {\r\n\t\t\tconst {scorer} = this;\r\n\r\n\t\t\t\t// associate each key with the scorer function, if it isn't already\r\n\t\t\t\t/* eslint object-curly-spacing: 0, object-property-newline: 0 */\r\n\t\t\tthis.keys = this.keys.map(keyItem => {\r\n\t\t\t\tconst key = (typeof keyItem == \"string\") ?\r\n\t\t\t\t\t{ name: keyItem, scorer } : keyItem;\r\n\r\n\t\t\t\tif (key.name.indexOf(\".\") > -1) {\r\n\t\t\t\t\tkey.path = key.name.split(\".\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn key;\r\n\t\t\t});\r\n\t\t\tthis.defaultKeyName = this.keys[0].name;\r\n\t\t} else {\r\n\t\t\t\t// defaultKeyName will be null if items is a flat array of\r\n\t\t\t\t// strings, which is handled in compareScoredStrings()\r\n\t\t\tthis.defaultKeyName = null;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets the `items` array and caches a lowercase copy of all the item\r\n\t * strings specified by the `keys` parameter to the constructor.\r\n\t *\r\n\t * @param {Array<string> | Array<object>} items - List of items to score.\r\n\t */\r\n\tsetItems(\r\n\t\titems)\r\n\t{\r\n\t\tconst {keys} = this;\r\n\t\tconst lcItems = [];\r\n\r\n\t\tthis.items = items;\r\n\t\tthis.lcItems = lcItems;\r\n\r\n\t\tif (keys.length) {\r\n\t\t\tfor (let i = 0, len = items.length; i < len; i++) {\r\n\t\t\t\tconst item = items[i];\r\n\t\t\t\tconst lc = {};\r\n\r\n\t\t\t\tfor (let j = 0, jlen = keys.length; j < jlen; j++) {\r\n\t\t\t\t\tconst key = keys[j];\r\n\t\t\t\t\tconst string = this.getItemString(item, key);\r\n\r\n\t\t\t\t\tif (string && typeof string == \"string\") {\r\n\t\t\t\t\t\tlc[key.name] = string.toLocaleLowerCase();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlcItems.push(lc);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let i = 0, len = items.length; i < len; i++) {\r\n\t\t\t\tlcItems.push(items[i].toLocaleLowerCase());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tgetItemString(\r\n\t\titem,\r\n\t\tkey)\r\n\t{\r\n\t\tconst {name, path} = key;\r\n\r\n\t\tif (path) {\r\n\t\t\treturn path.reduce((value, prop) => value && value[prop], item);\r\n\t\t} else {\r\n\t\t\treturn item[name];\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tcompareScoredStrings(\r\n\t\ta,\r\n\t\tb)\r\n\t{\r\n\t\t\t// use the lowercase versions of the strings for sorting\r\n\t\tconst itemA = a._;\r\n\t\tconst itemB = b._;\r\n\t\tconst itemAString = typeof itemA == \"string\" ? itemA :\r\n\t\t\titemA[this.defaultKeyName];\r\n\t\tconst itemBString = typeof itemB == \"string\" ? itemB :\r\n\t\t\titemB[this.defaultKeyName];\r\n\r\n\t\tif (a.score == b.score) {\r\n\t\t\t\t// sort undefineds to the end of the array, as per the ES spec\r\n\t\t\tif (itemAString === undefined || itemBString === undefined) {\r\n\t\t\t\tif (itemAString === undefined && itemBString === undefined) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t} else if (itemAString == undefined) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t} else if (itemAString == itemBString) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else if (itemAString < itemBString) {\r\n\t\t\t\treturn -1;\r\n\t\t\t} else {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn b.score - a.score;\r\n\t\t}\r\n\t}\r\n}\n\nexport { BaseConfig, DefaultConfig, QuickScore, QuicksilverConfig, Range, createConfig, quickScore };\n","import {QuickScore} from \"quick-score\";\r\nwindow.QuickScore = QuickScore;"]}